<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF8" http-equiv="Content-Type">

<title>class LibXML::XML::Document - LibXML</title>

<link type="text/css" media="screen" href="../../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../../index.html">Home</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>ext/libxml/libxml.c
    <li>lib/libxml/document.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link"><a href="../../Object.html">Object</a>
  
</nav>

    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li><a href="#method-c-document">::document</a>
    
    <li><a href="#method-c-file">::file</a>
    
    <li><a href="#method-c-io">::io</a>
    
    <li><a href="#method-c-new">::new</a>
    
    <li><a href="#method-c-string">::string</a>
    
    <li><a href="#method-i-canonicalize">#canonicalize</a>
    
    <li><a href="#method-i-child">#child</a>
    
    <li><a href="#method-i-child-3F">#child?</a>
    
    <li><a href="#method-i-compression">#compression</a>
    
    <li><a href="#method-i-compression-3D">#compression=</a>
    
    <li><a href="#method-i-compression-3F">#compression?</a>
    
    <li><a href="#method-i-context">#context</a>
    
    <li><a href="#method-i-debug">#debug</a>
    
    <li><a href="#method-i-encoding">#encoding</a>
    
    <li><a href="#method-i-encoding-3D">#encoding=</a>
    
    <li><a href="#method-i-find">#find</a>
    
    <li><a href="#method-i-find_first">#find_first</a>
    
    <li><a href="#method-i-import">#import</a>
    
    <li><a href="#method-i-last">#last</a>
    
    <li><a href="#method-i-last-3F">#last?</a>
    
    <li><a href="#method-i-next">#next</a>
    
    <li><a href="#method-i-next-3F">#next?</a>
    
    <li><a href="#method-i-node_type">#node_type</a>
    
    <li><a href="#method-i-node_type_name">#node_type_name</a>
    
    <li><a href="#method-i-order_elements-21">#order_elements!</a>
    
    <li><a href="#method-i-parent">#parent</a>
    
    <li><a href="#method-i-parent-3F">#parent?</a>
    
    <li><a href="#method-i-prev">#prev</a>
    
    <li><a href="#method-i-prev-3F">#prev?</a>
    
    <li><a href="#method-i-rb_encoding">#rb_encoding</a>
    
    <li><a href="#method-i-root">#root</a>
    
    <li><a href="#method-i-root-3D">#root=</a>
    
    <li><a href="#method-i-save">#save</a>
    
    <li><a href="#method-i-standalone-3F">#standalone?</a>
    
    <li><a href="#method-i-to_s">#to_s</a>
    
    <li><a href="#method-i-url">#url</a>
    
    <li><a href="#method-i-validate">#validate</a>
    
    <li><a href="#method-i-validate_relaxng">#validate_relaxng</a>
    
    <li><a href="#method-i-validate_schema">#validate_schema</a>
    
    <li><a href="#method-i-version">#version</a>
    
    <li><a href="#method-i-xhtml-3F">#xhtml?</a>
    
    <li><a href="#method-i-xinclude">#xinclude</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../../HISTORY.html">HISTORY</a>
  
    <li class="file"><a href="../../LICENSE.html">LICENSE</a>
  
    <li class="file"><a href="../../README_rdoc.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../../LibXML.html">LibXML</a>
  
    <li><a href="../../LibXML/XML.html">LibXML::XML</a>
  
    <li><a href="../../LibXML/XML/Attr.html">LibXML::XML::Attr</a>
  
    <li><a href="../../LibXML/XML/AttrDecl.html">LibXML::XML::AttrDecl</a>
  
    <li><a href="../../LibXML/XML/Attributes.html">LibXML::XML::Attributes</a>
  
    <li><a href="../../LibXML/XML/Document.html">LibXML::XML::Document</a>
  
    <li><a href="../../LibXML/XML/Dtd.html">LibXML::XML::Dtd</a>
  
    <li><a href="../../LibXML/XML/Encoding.html">LibXML::XML::Encoding</a>
  
    <li><a href="../../LibXML/XML/Error.html">LibXML::XML::Error</a>
  
    <li><a href="../../LibXML/XML/HTMLParser.html">LibXML::XML::HTMLParser</a>
  
    <li><a href="../../LibXML/XML/HTMLParser/Context.html">LibXML::XML::HTMLParser::Context</a>
  
    <li><a href="../../LibXML/XML/HTMLParser/Options.html">LibXML::XML::HTMLParser::Options</a>
  
    <li><a href="../../LibXML/XML/InputCallbacks.html">LibXML::XML::InputCallbacks</a>
  
    <li><a href="../../LibXML/XML/Namespace.html">LibXML::XML::Namespace</a>
  
    <li><a href="../../LibXML/XML/Namespaces.html">LibXML::XML::Namespaces</a>
  
    <li><a href="../../LibXML/XML/Node.html">LibXML::XML::Node</a>
  
    <li><a href="../../LibXML/XML/Parser.html">LibXML::XML::Parser</a>
  
    <li><a href="../../LibXML/XML/Parser/Context.html">LibXML::XML::Parser::Context</a>
  
    <li><a href="../../LibXML/XML/Parser/Options.html">LibXML::XML::Parser::Options</a>
  
    <li><a href="../../LibXML/XML/Reader.html">LibXML::XML::Reader</a>
  
    <li><a href="../../LibXML/XML/RelaxNG.html">LibXML::XML::RelaxNG</a>
  
    <li><a href="../../LibXML/XML/SaxParser.html">LibXML::XML::SaxParser</a>
  
    <li><a href="../../LibXML/XML/SaxParser/Callbacks.html">LibXML::XML::SaxParser::Callbacks</a>
  
    <li><a href="../../LibXML/XML/SaxParser/VerboseCallbacks.html">LibXML::XML::SaxParser::VerboseCallbacks</a>
  
    <li><a href="../../LibXML/XML/Schema.html">LibXML::XML::Schema</a>
  
    <li><a href="../../LibXML/XML/Schema/Attribute.html">LibXML::XML::Schema::Attribute</a>
  
    <li><a href="../../LibXML/XML/Schema/Element.html">LibXML::XML::Schema::Element</a>
  
    <li><a href="../../LibXML/XML/Schema/Facet.html">LibXML::XML::Schema::Facet</a>
  
    <li><a href="../../LibXML/XML/Schema/Namespaces.html">LibXML::XML::Schema::Namespaces</a>
  
    <li><a href="../../LibXML/XML/Schema/Type.html">LibXML::XML::Schema::Type</a>
  
    <li><a href="../../LibXML/XML/Schema/Types.html">LibXML::XML::Schema::Types</a>
  
    <li><a href="../../LibXML/XML/Writer.html">LibXML::XML::Writer</a>
  
    <li><a href="../../LibXML/XML/XInclude.html">LibXML::XML::XInclude</a>
  
    <li><a href="../../LibXML/XML/XPath.html">LibXML::XML::XPath</a>
  
    <li><a href="../../LibXML/XML/XPath/Context.html">LibXML::XML::XPath::Context</a>
  
    <li><a href="../../LibXML/XML/XPath/Expression.html">LibXML::XML::XPath::Expression</a>
  
    <li><a href="../../LibXML/XML/XPath/Object.html">LibXML::XML::XPath::Object</a>
  
    <li><a href="../../LibXML/XML/XPointer.html">LibXML::XML::XPointer</a>
  
    <li><a href="../../Float.html">Float</a>
  
    <li><a href="../../Object.html">Object</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class LibXML::XML::Document</h1>

  <div id="description" class="description">
    
<p>The <a href="Document.html">XML::Document</a> class provides a tree based
API for working with xml documents.  You may directly create a document and
manipulate it, or create a document from a data source by using an <a
href="Parser.html">XML::Parser</a> object.</p>

<p>To read a document from a file:</p>

<pre>doc = XML::Document.file('my_file')</pre>

<p>To use a parser to read a document:</p>

<pre>parser = XML::Parser.file('my_file')
doc = parser.parse</pre>

<p>To create a document from scratch:</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>()
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">root</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'root_node'</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">root</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'elem1'</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">save</span>(<span class="ruby-identifier">filename</span>, :<span class="ruby-identifier">indent</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, :<span class="ruby-identifier">encoding</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">UTF_8</span>)
</pre>

<p>To write a document to a file:</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>()
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">root</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'root_node'</span>)
<span class="ruby-identifier">root</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">root</span>

<span class="ruby-identifier">root</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">elem1</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'elem1'</span>)
<span class="ruby-identifier">elem1</span>[<span class="ruby-string">'attr1'</span>] = <span class="ruby-string">'val1'</span>
<span class="ruby-identifier">elem1</span>[<span class="ruby-string">'attr2'</span>] = <span class="ruby-string">'val2'</span>

<span class="ruby-identifier">root</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">elem2</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'elem2'</span>)
<span class="ruby-identifier">elem2</span>[<span class="ruby-string">'attr1'</span>] = <span class="ruby-string">'val1'</span>
<span class="ruby-identifier">elem2</span>[<span class="ruby-string">'attr2'</span>] = <span class="ruby-string">'val2'</span>

<span class="ruby-identifier">root</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">elem3</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'elem3'</span>)
<span class="ruby-identifier">elem3</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">elem4</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'elem4'</span>)
<span class="ruby-identifier">elem3</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">elem5</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'elem5'</span>)

<span class="ruby-identifier">elem5</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">elem6</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'elem6'</span>)
<span class="ruby-identifier">elem6</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">'Content for element 6'</span>

<span class="ruby-identifier">elem3</span>[<span class="ruby-string">'attr'</span>] = <span class="ruby-string">'baz'</span>

<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">save</span>(<span class="ruby-identifier">filename</span>, :<span class="ruby-identifier">indent</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, :<span class="ruby-identifier">encoding</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">UTF_8</span>)
</pre>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="XML_C14N_1_0">XML_C14N_1_0
        
        <dd class="description"><p>Original C14N 1.0 spec</p>
        
      
        <dt id="XML_C14N_1_1">XML_C14N_1_1
        
        <dd class="description"><p>C14N 1.1 spec</p>
        
      
        <dt id="XML_C14N_EXCLUSIVE_1_0">XML_C14N_EXCLUSIVE_1_0
        
        <dd class="description"><p>Exclusive C14N 1.0 spec</p>
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-document" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            XML::Document.document(document) &rarr; XML::Document
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new document based on the specified document.</p>

<p>Parameters:</p>

<pre>document - A preparsed document.</pre>
          

          
          <div class="method-source-code" id="document-source">
            <pre><span class="ruby-comment"># File lib/libxml/document.rb, line 13</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">document</span>(<span class="ruby-identifier">value</span>)
  <span class="ruby-constant">Parser</span>.<span class="ruby-identifier">document</span>(<span class="ruby-identifier">value</span>).<span class="ruby-identifier">parse</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- document-source -->
          
        </div>

        

        
      </div><!-- document-method -->

    
      <div id="method-c-file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            XML::Document.file(path) &rarr; XML::Document
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            XML::Document.file(path, :encoding &rarr; XML::Encoding::UTF_8,
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            :options =&gt; XML::Parser::Options::NOENT) &rarr; XML::Document
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new document from the specified file or uri.</p>

<p>You may provide an optional hash table to control how the parsing is
performed.  Valid options are:</p>

<pre>encoding - The document encoding, defaults to nil. Valid values
           are the encoding constants defined on XML::Encoding.
options - Parser options.  Valid values are the constants defined on
          XML::Parser::Options.  Mutliple options can be combined
          by using Bitwise OR (|).</pre>
          

          
          <div class="method-source-code" id="file-source">
            <pre><span class="ruby-comment"># File lib/libxml/document.rb, line 32</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">file</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-constant">Parser</span>.<span class="ruby-identifier">file</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">options</span>).<span class="ruby-identifier">parse</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- file-source -->
          
        </div>

        

        
      </div><!-- file-method -->

    
      <div id="method-c-io" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            XML::Document.io(io) &rarr; XML::Document
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            XML::Document.io(io, :encoding &rarr; XML::Encoding::UTF_8,
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            :options &rarr; XML::Parser::Options::NOENT
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            :base_uri=&quot;http://libxml.org&quot;) &rarr; XML::Document
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new document from the specified io object.</p>

<p>Parameters:</p>

<pre>io - io object that contains the xml to parser
base_uri - The base url for the parsed document.
encoding - The document encoding, defaults to nil. Valid values
           are the encoding constants defined on XML::Encoding.
options - Parser options.  Valid values are the constants defined on
          XML::Parser::Options.  Mutliple options can be combined
          by using Bitwise OR (|).</pre>
          

          
          <div class="method-source-code" id="io-source">
            <pre><span class="ruby-comment"># File lib/libxml/document.rb, line 53</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">io</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-constant">Parser</span>.<span class="ruby-identifier">io</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">options</span>).<span class="ruby-identifier">parse</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- io-source -->
          
        </div>

        

        
      </div><!-- io-method -->

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            XML::Document.initialize(xml_version = 1.0) &rarr; document
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Initializes a new <a href="Document.html">XML::Document</a>, optionally
specifying the <a href="../XML.html">XML</a> version.</p>
          

          
          <div class="method-source-code" id="new-source">
            <pre>static VALUE rxml_document_initialize(int argc, VALUE *argv, VALUE self)
{
  xmlDocPtr xdoc;
  VALUE xmlver;

  switch (argc)
  {
  case 0:
    xmlver = rb_str_new2(&quot;1.0&quot;);
    break;
  case 1:
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;xmlver);
    break;
  default:
    rb_raise(rb_eArgError, &quot;wrong number of arguments (need 0 or 1)&quot;);
  }

  Check_Type(xmlver, T_STRING);
  xdoc = xmlNewDoc((xmlChar*) StringValuePtr(xmlver));
  xdoc-&gt;_private = (void*) self;
  DATA_PTR(self) = xdoc;

  return self;
}</pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
      <div id="method-c-string" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            XML::Document.string(string) &rarr; XML::Document
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            XML::Document.string(string, :encoding &rarr; XML::Encoding::UTF_8,
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            :options &rarr; XML::Parser::Options::NOENT
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            :base_uri=&quot;http://libxml.org&quot;) &rarr; XML::Document
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new document from the specified string.</p>

<p>You may provide an optional hash table to control how the parsing is
performed.  Valid options are:</p>

<pre>base_uri - The base url for the parsed document.
encoding - The document encoding, defaults to nil. Valid values
           are the encoding constants defined on XML::Encoding.
options  - Parser options.  Valid values are the constants defined on
           XML::Parser::Options.  Mutliple options can be combined
           by using Bitwise OR (|).</pre>
          

          
          <div class="method-source-code" id="string-source">
            <pre><span class="ruby-comment"># File lib/libxml/document.rb, line 74</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">string</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-constant">Parser</span>.<span class="ruby-identifier">string</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">options</span>).<span class="ruby-identifier">parse</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- string-source -->
          
        </div>

        

        
      </div><!-- string-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-canonicalize" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">canonicalize</span><span
            class="method-args">(p1 = v1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="canonicalize-source">
            <pre>static VALUE
rxml_document_canonicalize(int argc, VALUE *argv, VALUE self)
{
  VALUE result = Qnil;
  int length;
  xmlDocPtr xdoc;
  xmlChar *buffer = NULL;
  VALUE option_hash = Qnil;
  VALUE o_nodes = Qnil;

  // :comments option
  VALUE comments = Qfalse;
  // :mode option
  int c14n_mode = XML_C14N_1_0;
  // :inclusive_ns_prefixes option (ARRAY)

  xmlChar * inc_ns_prefixes_ptr[C14N_NS_LIMIT];

  // :nodes option (ARRAY)
  xmlNodePtr  node_ptr_array[C14N_NODESET_LIMIT];
  xmlNodeSet nodeset = {
    0, C14N_NODESET_LIMIT, NULL
  };

  /* At least one NULL value must be defined in the array or the extension will
   * segfault when using XML_C14N_EXCLUSIVE_1_0 mode.
   * API docs: &quot;list of inclusive namespace prefixes ended with a NULL&quot;
   */
  inc_ns_prefixes_ptr[0] = NULL;

  rb_scan_args(argc, argv, &quot;01&quot;, &amp;option_hash);
  // Do stuff if ruby hash passed as argument
  if (!NIL_P(option_hash)) 
  {
        VALUE o_comments = Qnil;
        VALUE o_mode = Qnil;
        VALUE o_i_ns_prefixes = Qnil;
                
    Check_Type(option_hash, T_HASH);

    o_comments = rb_hash_aref(option_hash, ID2SYM(rb_intern(&quot;comments&quot;)));
    comments = (RTEST(o_comments) ? 1 : 0);

    o_mode = rb_hash_aref(option_hash, ID2SYM(rb_intern(&quot;mode&quot;)));
    if (!NIL_P(o_mode)) 
        {
      Check_Type(o_mode, T_FIXNUM);
      c14n_mode = NUM2INT(o_mode);
      //TODO: clean this up
      //if (c14n_mode &gt; 2) { c14n_mode = 0; }
      //mode_int = (NUM2INT(o_mode) &gt; 2 ? 0 : NUM2INT(o_mode));
    }

    o_i_ns_prefixes = rb_hash_aref(option_hash, ID2SYM(rb_intern(&quot;inclusive_ns_prefixes&quot;)));
    if (!NIL_P(o_i_ns_prefixes)) 
        {
      int i;
      int p = 0; //pointer array index
      VALUE *list_in = NULL;
      int list_size = 0;

          Check_Type(o_i_ns_prefixes, T_ARRAY);
      list_in = RARRAY_PTR(o_i_ns_prefixes);
      list_size = RARRAY_LEN(o_i_ns_prefixes);

      if (list_size &gt; 0) 
          {
        for(i=0; i &lt; list_size; ++i) {
          if (p &gt;= C14N_NS_LIMIT) { break; }

          if (RTEST(list_in[i])) 
                  {
            if (TYPE(list_in[i]) == T_STRING) 
                        {
              inc_ns_prefixes_ptr[p] = (xmlChar *)StringValueCStr(list_in[i]);
              p++;
            }
          }
        }
      }

      // ensure p is not out of bound
      p = (p &gt;= C14N_NS_LIMIT ? (C14N_NS_LIMIT-1) : p);

      // API docs: &quot;list of inclusive namespace prefixes ended with a NULL&quot;
      // Set last element to NULL
      inc_ns_prefixes_ptr[p] = NULL;
    }
    //o_ns_prefixes will free at end of block

    o_nodes = rb_hash_aref(option_hash, ID2SYM(rb_intern(&quot;nodes&quot;)));
    if (!NIL_P(o_nodes)) 
        {
      int i;
      int p = 0; // index of pointer array
      VALUE * list_in = NULL;
      int node_list_size = 0;

          if (CLASS_OF(o_nodes) == cXMLXPathObject)
          {
                  o_nodes = rb_funcall(o_nodes, rb_intern(&quot;to_a&quot;), 0);
          }
          else
          {
                  Check_Type(o_nodes, T_ARRAY);
          }
      list_in = RARRAY_PTR(o_nodes);
      node_list_size = RARRAY_LEN(o_nodes);

      for (i=0; i &lt; node_list_size; ++i)
          {
        if (p &gt;= C14N_NODESET_LIMIT) { break; }

        if (RTEST(list_in[i])) 
                {
          xmlNodePtr node_ptr;
          Data_Get_Struct(list_in[i], xmlNode, node_ptr);
          node_ptr_array[p] = node_ptr;
          p++;
        }
      }

      // Need to set values in nodeset struct
      nodeset.nodeNr = (node_list_size &gt; C14N_NODESET_LIMIT ?
                        C14N_NODESET_LIMIT :
                        node_list_size);
      nodeset.nodeTab = node_ptr_array;
    }
  }//option_hash

  Data_Get_Struct(self, xmlDoc, xdoc);
  length = xmlC14NDocDumpMemory(
    xdoc,
    (nodeset.nodeNr == 0 ? NULL : &amp;nodeset),
    c14n_mode,
    inc_ns_prefixes_ptr,
    comments,
    &amp;buffer
  );

  if (buffer)
  {
    result = rxml_new_cstr((const char*) buffer, NULL);
    xmlFree(buffer);
  }

  return result;
}</pre>
          </div><!-- canonicalize-source -->
          
        </div>

        

        
      </div><!-- canonicalize-method -->

    
      <div id="method-i-child" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            child &rarr; node
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get this document's child node.</p>
          

          
          <div class="method-source-code" id="child-source">
            <pre>static VALUE rxml_document_child_get(VALUE self)
{
  xmlDocPtr xdoc;
  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;children == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc-&gt;children);
}</pre>
          </div><!-- child-source -->
          
        </div>

        

        
      </div><!-- child-method -->

    
      <div id="method-i-child-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            child? &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this document has a child node.</p>
          

          
          <div class="method-source-code" id="child-3F-source">
            <pre>static VALUE rxml_document_child_q(VALUE self)
{
  xmlDocPtr xdoc;
  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;children == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}</pre>
          </div><!-- child-3F-source -->
          
        </div>

        

        
      </div><!-- child-3F-method -->

    
      <div id="method-i-compression" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            compression &rarr; num
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain this document's compression mode identifier.</p>
          

          
          <div class="method-source-code" id="compression-source">
            <pre>static VALUE rxml_document_compression_get(VALUE self)
{
#ifdef HAVE_ZLIB_H
  xmlDocPtr xdoc;

  int compmode;
  Data_Get_Struct(self, xmlDoc, xdoc);

  compmode = xmlGetDocCompressMode(xdoc);
  if (compmode == -1)
  return(Qnil);
  else
  return(INT2NUM(compmode));
#else
  rb_warn(&quot;libxml not compiled with zlib support&quot;);
  return (Qfalse);
#endif
}</pre>
          </div><!-- compression-source -->
          
        </div>

        

        
      </div><!-- compression-method -->

    
      <div id="method-i-compression-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            compression = num
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set this document's compression mode.</p>
          

          
          <div class="method-source-code" id="compression-3D-source">
            <pre>static VALUE rxml_document_compression_set(VALUE self, VALUE num)
{
#ifdef HAVE_ZLIB_H
  xmlDocPtr xdoc;

  int compmode;
  Check_Type(num, T_FIXNUM);
  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc == NULL)
  {
    return(Qnil);
  }
  else
  {
    xmlSetDocCompressMode(xdoc, NUM2INT(num));

    compmode = xmlGetDocCompressMode(xdoc);
    if (compmode == -1)
    return(Qnil);
    else
    return(INT2NUM(compmode));
  }
#else
  rb_warn(&quot;libxml compiled without zlib support&quot;);
  return (Qfalse);
#endif
}</pre>
          </div><!-- compression-3D-source -->
          
        </div>

        

        
      </div><!-- compression-3D-method -->

    
      <div id="method-i-compression-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            compression? &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this document is compressed.</p>
          

          
          <div class="method-source-code" id="compression-3F-source">
            <pre>static VALUE rxml_document_compression_q(VALUE self)
{
#ifdef HAVE_ZLIB_H
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;compression != -1)
  return(Qtrue);
  else
  return(Qfalse);
#else
  rb_warn(&quot;libxml compiled without zlib support&quot;);
  return (Qfalse);
#endif
}</pre>
          </div><!-- compression-3F-source -->
          
        </div>

        

        
      </div><!-- compression-3F-method -->

    
      <div id="method-i-context" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            context(namespaces=nil) &rarr; XPath::Context
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new XML::XPathContext for the document.</p>

<p><a href="Namespaces.html">Namespaces</a> is an optional array of XML::NS
objects</p>
          

          
          <div class="method-source-code" id="context-source">
            <pre><span class="ruby-comment"># File lib/libxml/document.rb, line 84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">context</span>(<span class="ruby-identifier">nslist</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">context</span> = <span class="ruby-constant">XPath</span><span class="ruby-operator">::</span><span class="ruby-constant">Context</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-identifier">context</span>.<span class="ruby-identifier">node</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">root</span>
  <span class="ruby-identifier">context</span>.<span class="ruby-identifier">register_namespaces_from_node</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">root</span>)
  <span class="ruby-identifier">context</span>.<span class="ruby-identifier">register_namespaces</span>(<span class="ruby-identifier">nslist</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">nslist</span>
  <span class="ruby-identifier">context</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- context-source -->
          
        </div>

        

        
      </div><!-- context-method -->

    
      <div id="method-i-debug" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            debug &rarr; true|false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Print libxml debugging information to stdout. Requires that libxml was
compiled with debugging enabled.</p>
          

          
          <div class="method-source-code" id="debug-source">
            <pre>static VALUE rxml_document_debug(VALUE self)
{
#ifdef LIBXML_DEBUG_ENABLED
  xmlDocPtr xdoc;
  Data_Get_Struct(self, xmlDoc, xdoc);
  xmlDebugDumpDocument(NULL, xdoc);
  return Qtrue;
#else
  rb_warn(&quot;libxml was compiled without debugging support.&quot;)
  return Qfalse;
#endif
}</pre>
          </div><!-- debug-source -->
          
        </div>

        

        
      </div><!-- debug-method -->

    
      <div id="method-i-encoding" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            encoding &rarr; XML::Encoding::UTF_8
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the <a href="../../LibXML.html">LibXML</a> encoding constant
specified by this document.</p>
          

          
          <div class="method-source-code" id="encoding-source">
            <pre>static VALUE rxml_document_encoding_get(VALUE self)
{
  xmlDocPtr xdoc;
  const char *xencoding;
  Data_Get_Struct(self, xmlDoc, xdoc);

  xencoding = (const char*)xdoc-&gt;encoding;
  return INT2NUM(xmlParseCharEncoding(xencoding));
}</pre>
          </div><!-- encoding-source -->
          
        </div>

        

        
      </div><!-- encoding-method -->

    
      <div id="method-i-encoding-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            encoding = XML::Encoding::UTF_8
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the encoding for this document.</p>
          

          
          <div class="method-source-code" id="encoding-3D-source">
            <pre>static VALUE rxml_document_encoding_set(VALUE self, VALUE encoding)
{
  xmlDocPtr xdoc;
  const char* xencoding = xmlGetCharEncodingName((xmlCharEncoding)NUM2INT(encoding));

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;encoding != NULL)
    xmlFree((xmlChar *) xdoc-&gt;encoding);

  xdoc-&gt;encoding = xmlStrdup((xmlChar *)xencoding);
  return self;
}</pre>
          </div><!-- encoding-3D-source -->
          
        </div>

        

        
      </div><!-- encoding-3D-method -->

    
      <div id="method-i-find" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            find(xpath, nslist=nil) &rarr; XML::XPath::Object
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return the nodes matching the specified xpath expression,  optionally using
the specified namespace.  For more  information about working with
namespaces, please refer to the <a href="XPath.html">XML::XPath</a>
documentation.</p>

<p>Parameters:</p>
<ul><li>
<p>xpath - The xpath expression as a string</p>
</li><li>
<p>namespaces - An optional list of namespaces (see <a
href="XPath.html">XML::XPath</a> for information).</p>
</li></ul>

<pre>document.find('/foo', 'xlink:http://www.w3.org/1999/xlink')</pre>

<p>IMPORTANT - The returned XML::Node::Set must be freed before its associated
document.  In a running Ruby program this will happen automatically via
Ruby's mark and sweep garbage collector. However, if the program exits,
Ruby does not guarantee the order in which objects are freed (see <a
href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/17700">blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/17700</a>).
As a result, the associated document may be freed before the node list,
which will cause a segmentation fault. To avoid this, use the following
(non-ruby like) coding style:</p>

<pre class="ruby"><span class="ruby-identifier">nodes</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">find</span>(<span class="ruby-string">'/header'</span>)
<span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
  <span class="ruby-operator">...</span> <span class="ruby-keyword">do</span> <span class="ruby-identifier">stuff</span> <span class="ruby-operator">...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>#  nodes = nil #  GC.start</p>
          

          
          <div class="method-source-code" id="find-source">
            <pre><span class="ruby-comment"># File lib/libxml/document.rb, line 121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">find</span>(<span class="ruby-identifier">xpath</span>, <span class="ruby-identifier">nslist</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">context</span>(<span class="ruby-identifier">nslist</span>).<span class="ruby-identifier">find</span>(<span class="ruby-identifier">xpath</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- find-source -->
          
        </div>

        

        
      </div><!-- find-method -->

    
      <div id="method-i-find_first" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">find_first</span><span
            class="method-args">(xpath, nslist = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Return the first node matching the specified xpath expression. For more
information, please refer to the documentation for <a
href="Document.html#method-i-find">#find</a>.</p>
          

          
          <div class="method-source-code" id="find_first-source">
            <pre><span class="ruby-comment"># File lib/libxml/document.rb, line 128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">find_first</span>(<span class="ruby-identifier">xpath</span>, <span class="ruby-identifier">nslist</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">find</span>(<span class="ruby-identifier">xpath</span>, <span class="ruby-identifier">nslist</span>).<span class="ruby-identifier">first</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- find_first-source -->
          
        </div>

        

        
      </div><!-- find_first-method -->

    
      <div id="method-i-import" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            import(node) &rarr; XML::Node
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a copy of the node that can be inserted into the current document.</p>

<p>IMPORTANT - The returned node MUST be inserted into the document. This is
because the returned node refereces internal <a
href="../../LibXML.html">LibXML</a> data structures owned by the document. 
Therefore, if the document is is freed before the the node is freed a
segmentation fault will occur.</p>
          

          
          <div class="method-source-code" id="import-source">
            <pre>static VALUE rxml_document_import(VALUE self, VALUE node)
{
  xmlDocPtr xdoc;
  xmlNodePtr xnode, xresult;

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(node, xmlNode, xnode);

  xresult = xmlDocCopyNode(xnode, xdoc, 1);

  if (xresult == NULL)
    rxml_raise(&amp;xmlLastError);

  return rxml_node_wrap(xresult);
}</pre>
          </div><!-- import-source -->
          
        </div>

        

        
      </div><!-- import-method -->

    
      <div id="method-i-last" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            last &rarr; node
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the last node.</p>
          

          
          <div class="method-source-code" id="last-source">
            <pre>static VALUE rxml_document_last_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;last == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc-&gt;last);
}</pre>
          </div><!-- last-source -->
          
        </div>

        

        
      </div><!-- last-method -->

    
      <div id="method-i-last-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            last? &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether there is a last node.</p>
          

          
          <div class="method-source-code" id="last-3F-source">
            <pre>static VALUE rxml_document_last_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;last == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}</pre>
          </div><!-- last-3F-source -->
          
        </div>

        

        
      </div><!-- last-3F-method -->

    
      <div id="method-i-next" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            next &rarr; node
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the next node.</p>
          

          
          <div class="method-source-code" id="next-source">
            <pre>static VALUE rxml_document_next_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;next == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc-&gt;next);
}</pre>
          </div><!-- next-source -->
          
        </div>

        

        
      </div><!-- next-method -->

    
      <div id="method-i-next-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            next? &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether there is a next node.</p>
          

          
          <div class="method-source-code" id="next-3F-source">
            <pre>static VALUE rxml_document_next_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;next == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}</pre>
          </div><!-- next-3F-source -->
          
        </div>

        

        
      </div><!-- next-3F-method -->

    
      <div id="method-i-node_type" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            type &rarr; num
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain this node's type identifier.</p>
          

          
          <div class="method-source-code" id="node_type-source">
            <pre>static VALUE rxml_document_node_type(VALUE self)
{
  xmlNodePtr xnode;
  Data_Get_Struct(self, xmlNode, xnode);
  return (INT2NUM(xnode-&gt;type));
}</pre>
          </div><!-- node_type-source -->
          
        </div>

        

        
      </div><!-- node_type-method -->

    
      <div id="method-i-node_type_name" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">node_type_name</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Returns this node's type name</p>
          

          
          <div class="method-source-code" id="node_type_name-source">
            <pre><span class="ruby-comment"># File lib/libxml/document.rb, line 133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">node_type_name</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">node_type</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span><span class="ruby-operator">::</span><span class="ruby-constant">DOCUMENT_NODE</span>
    <span class="ruby-string">'document_xml'</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span><span class="ruby-operator">::</span><span class="ruby-constant">DOCB_DOCUMENT_NODE</span>
    <span class="ruby-string">'document_docbook'</span>
  <span class="ruby-keyword">when</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span><span class="ruby-operator">::</span><span class="ruby-constant">HTML_DOCUMENT_NODE</span>
    <span class="ruby-string">'document_html'</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">UnknownType</span>, <span class="ruby-string">&quot;Unknown node type: %n&quot;</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">node_type</span>);
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- node_type_name-source -->
          
        </div>

        

        
      </div><!-- node_type_name-method -->

    
      <div id="method-i-order_elements-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            order_elements!
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Call this routine to speed up <a href="XPath.html">XPath</a> computation on
static documents. This stamps all the element nodes with the document
order.</p>
          

          
          <div class="method-source-code" id="order_elements-21-source">
            <pre>static VALUE rxml_document_order_elements(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);
  return LONG2FIX(xmlXPathOrderDocElems(xdoc));
}</pre>
          </div><!-- order_elements-21-source -->
          
        </div>

        

        
      </div><!-- order_elements-21-method -->

    
      <div id="method-i-parent" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            parent &rarr; node
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the parent node.</p>
          

          
          <div class="method-source-code" id="parent-source">
            <pre>static VALUE rxml_document_parent_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;parent == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc-&gt;parent);
}</pre>
          </div><!-- parent-source -->
          
        </div>

        

        
      </div><!-- parent-method -->

    
      <div id="method-i-parent-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            parent? &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether there is a parent node.</p>
          

          
          <div class="method-source-code" id="parent-3F-source">
            <pre>static VALUE rxml_document_parent_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;parent == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}</pre>
          </div><!-- parent-3F-source -->
          
        </div>

        

        
      </div><!-- parent-3F-method -->

    
      <div id="method-i-prev" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            prev &rarr; node
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the previous node.</p>
          

          
          <div class="method-source-code" id="prev-source">
            <pre>static VALUE rxml_document_prev_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;prev == NULL)
    return (Qnil);

  return rxml_node_wrap(xdoc-&gt;prev);
}</pre>
          </div><!-- prev-source -->
          
        </div>

        

        
      </div><!-- prev-method -->

    
      <div id="method-i-prev-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            prev? &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether there is a previous node.</p>
          

          
          <div class="method-source-code" id="prev-3F-source">
            <pre>static VALUE rxml_document_prev_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);

  if (xdoc-&gt;prev == NULL)
    return (Qfalse);
  else
    return (Qtrue);
}</pre>
          </div><!-- prev-3F-source -->
          
        </div>

        

        
      </div><!-- prev-3F-method -->

    
      <div id="method-i-rb_encoding" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rb_encoding</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="rb_encoding-source">
            <pre>static VALUE rxml_document_rb_encoding_get(VALUE self)
{
  xmlDocPtr xdoc;
  const char *xencoding;
  rb_encoding* rbencoding;
  Data_Get_Struct(self, xmlDoc, xdoc);

  xencoding = (const char*)xdoc-&gt;encoding;
  rbencoding = rxml_xml_encoding_to_rb_encoding(mXMLEncoding, xmlParseCharEncoding(xencoding));
  return rb_enc_from_encoding(rbencoding);
}</pre>
          </div><!-- rb_encoding-source -->
          
        </div>

        

        
      </div><!-- rb_encoding-method -->

    
      <div id="method-i-root" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            root &rarr; node
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the root node.</p>
          

          
          <div class="method-source-code" id="root-source">
            <pre>static VALUE rxml_document_root_get(VALUE self)
{
  xmlDocPtr xdoc;

  xmlNodePtr root;

  Data_Get_Struct(self, xmlDoc, xdoc);
  root = xmlDocGetRootElement(xdoc);

  if (root == NULL)
    return (Qnil);

  return rxml_node_wrap(root);
}</pre>
          </div><!-- root-source -->
          
        </div>

        

        
      </div><!-- root-method -->

    
      <div id="method-i-root-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            root = node
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the root node.</p>
          

          
          <div class="method-source-code" id="root-3D-source">
            <pre>static VALUE rxml_document_root_set(VALUE self, VALUE node)
{
  xmlDocPtr xdoc;
  xmlNodePtr xroot, xnode;

  if (rb_obj_is_kind_of(node, cXMLNode) == Qfalse)
    rb_raise(rb_eTypeError, &quot;must pass an XML::Node type object&quot;);

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(node, xmlNode, xnode);

  if (xnode-&gt;doc != NULL &amp;&amp; xnode-&gt;doc != xdoc)
    rb_raise(eXMLError, &quot;Nodes belong to different documents.  You must first import the node by calling XML::Document.import&quot;);

  xroot = xmlDocSetRootElement(xdoc, xnode);
  return node;
}</pre>
          </div><!-- root-3D-source -->
          
        </div>

        

        
      </div><!-- root-3D-method -->

    
      <div id="method-i-save" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            save(filename) &rarr; int
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            save(filename, :indent =&gt; true, :encoding =&gt; XML::Encoding::UTF_8) &rarr; int
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Saves a document to a file.  You may provide an optional hash table to
control how the string is generated.  Valid options are:</p>

<p>:indent - Specifies if the string should be indented.  The default value is
true.  Note that indentation is only added if both :indent is true and <a
href="../XML.html#method-c-indent_tree_output">LibXML::XML.indent_tree_output</a>
is true.  If :indent is set to false, then both indentation and line feeds
are removed from the result.</p>

<p>:encoding - Specifies the output encoding of the string.  It defaults to
the original encoding of the document (see <a
href="Document.html#method-i-encoding">encoding</a>.  To override the
orginal encoding, use one of the <a href="Encoding.html">XML::Encoding</a>
encoding constants.</p>
          

          
          <div class="method-source-code" id="save-source">
            <pre>static VALUE rxml_document_save(int argc, VALUE *argv, VALUE self)
{
  VALUE options = Qnil;
  VALUE filename = Qnil;
  xmlDocPtr xdoc;
  int indent = 1;
  const char *xfilename;
  const char *xencoding;
  int length;

  rb_scan_args(argc, argv, &quot;11&quot;, &amp;filename, &amp;options);

  Check_Type(filename, T_STRING);
  xfilename = StringValuePtr(filename);

  Data_Get_Struct(self, xmlDoc, xdoc);
  xencoding = xdoc-&gt;encoding;

  if (!NIL_P(options))
  {
    VALUE rencoding, rindent;
    Check_Type(options, T_HASH);
    rencoding = rb_hash_aref(options, ID2SYM(rb_intern(&quot;encoding&quot;)));
    rindent = rb_hash_aref(options, ID2SYM(rb_intern(&quot;indent&quot;)));

    if (rindent == Qfalse)
      indent = 0;

    if (rencoding != Qnil)
    {
      xencoding = xmlGetCharEncodingName((xmlCharEncoding)NUM2INT(rencoding));
      if (!xencoding)
        rb_raise(rb_eArgError, &quot;Unknown encoding value: %d&quot;, NUM2INT(rencoding));
    }
  }

  length = xmlSaveFormatFileEnc(xfilename, xdoc, xencoding, indent);

  if (length == -1)
    rxml_raise(&amp;xmlLastError);

  return (INT2NUM(length));
}</pre>
          </div><!-- save-source -->
          
        </div>

        

        
      </div><!-- save-method -->

    
      <div id="method-i-standalone-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            standalone? &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this is a standalone document.</p>
          

          
          <div class="method-source-code" id="standalone-3F-source">
            <pre>static VALUE rxml_document_standalone_q(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);
  if (xdoc-&gt;standalone)
    return (Qtrue);
  else
    return (Qfalse);
}</pre>
          </div><!-- standalone-3F-source -->
          
        </div>

        

        
      </div><!-- standalone-3F-method -->

    
      <div id="method-i-to_s" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_s &rarr; &quot;string&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            to_s(:indent =&gt; true, :encoding =&gt; XML::Encoding::UTF_8) &rarr; &quot;string&quot;
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts a document, and all of its children, to a string representation.
You may provide an optional hash table to control how the string is
generated.  Valid options are:</p>

<p>:indent - Specifies if the string should be indented.  The default value is
true.  Note that indentation is only added if both :indent is true and <a
href="../XML.html#method-c-indent_tree_output">LibXML::XML.indent_tree_output</a>
is true.  If :indent is set to false, then both indentation and line feeds
are removed from the result.</p>

<p>:encoding - Specifies the output encoding of the string.  It defaults to
XML::Encoding::UTF8.  To change it, use one of the <a
href="Encoding.html">XML::Encoding</a> encoding constants.</p>
          

          
          <div class="method-source-code" id="to_s-source">
            <pre>static VALUE rxml_document_to_s(int argc, VALUE *argv, VALUE self)
{
  VALUE result;
  VALUE options = Qnil;
  xmlDocPtr xdoc;
  int indent = 1;
  const char *xencoding = &quot;UTF-8&quot;;
  xmlChar *buffer;
  int length;

  rb_scan_args(argc, argv, &quot;01&quot;, &amp;options);

  if (!NIL_P(options))
  {
    VALUE rencoding, rindent;
    Check_Type(options, T_HASH);
    rencoding = rb_hash_aref(options, ID2SYM(rb_intern(&quot;encoding&quot;)));
    rindent = rb_hash_aref(options, ID2SYM(rb_intern(&quot;indent&quot;)));

    if (rindent == Qfalse)
      indent = 0;

    if (rencoding != Qnil)
    {
      xencoding = xmlGetCharEncodingName((xmlCharEncoding)NUM2INT(rencoding));
      if (!xencoding)
        rb_raise(rb_eArgError, &quot;Unknown encoding value: %d&quot;, NUM2INT(rencoding));
    }
  }

  Data_Get_Struct(self, xmlDoc, xdoc);
  xmlDocDumpFormatMemoryEnc(xdoc, &amp;buffer, &amp;length, xencoding, indent);

  result = rxml_new_cstr((const char*) buffer, xencoding);
  xmlFree(buffer);
  return result;
}</pre>
          </div><!-- to_s-source -->
          
        </div>

        

        
      </div><!-- to_s-method -->

    
      <div id="method-i-url" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            url &rarr; &quot;url&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain this document's source URL, if any.</p>
          

          
          <div class="method-source-code" id="url-source">
            <pre>static VALUE rxml_document_url_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);
  if (xdoc-&gt;URL == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) xdoc-&gt;URL, NULL));
}</pre>
          </div><!-- url-source -->
          
        </div>

        

        
      </div><!-- url-method -->

    
      <div id="method-i-validate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            validate(dtd) &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Validate this document against the specified XML::DTD. If the document is
valid the method returns true.  Otherwise an exception is raised with
validation information.</p>
          

          
          <div class="method-source-code" id="validate-source">
            <pre>static VALUE rxml_document_validate_dtd(VALUE self, VALUE dtd)
{
  xmlValidCtxt ctxt;
  xmlDocPtr xdoc;
  xmlDtdPtr xdtd;

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(dtd, xmlDtd, xdtd);

  /* Setup context */
  memset(&amp;ctxt, 0, sizeof(xmlValidCtxt));

  if (xmlValidateDtd(&amp;ctxt, xdoc, xdtd))
  {
    return Qtrue;
  }
  else
  {
    rxml_raise(&amp;xmlLastError);
    return Qfalse;
  }
}</pre>
          </div><!-- validate-source -->
          
        </div>

        

        
      </div><!-- validate-method -->

    
      <div id="method-i-validate_relaxng" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            validate_relaxng(relaxng)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Validate this document against the specified <a
href="RelaxNG.html">XML::RelaxNG</a>. If the document is valid the method
returns true.  Otherwise an exception is raised with validation
information.</p>
          

          
          <div class="method-source-code" id="validate_relaxng-source">
            <pre>static VALUE rxml_document_validate_relaxng(VALUE self, VALUE relaxng)
{
  xmlRelaxNGValidCtxtPtr vptr;
  xmlDocPtr xdoc;
  xmlRelaxNGPtr xrelaxng;
  int is_invalid;

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(relaxng, xmlRelaxNG, xrelaxng);

  vptr = xmlRelaxNGNewValidCtxt(xrelaxng);

  is_invalid = xmlRelaxNGValidateDoc(vptr, xdoc);
  xmlRelaxNGFreeValidCtxt(vptr);
  if (is_invalid)
  {
    rxml_raise(&amp;xmlLastError);
    return Qfalse;
  }
  else
  {
    return Qtrue;
  }
}</pre>
          </div><!-- validate_relaxng-source -->
          
        </div>

        

        
      </div><!-- validate_relaxng-method -->

    
      <div id="method-i-validate_schema" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            validate_schema(schema)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Validate this document against the specified <a
href="Schema.html">XML::Schema</a>. If the document is valid the method
returns true.  Otherwise an exception is raised with validation
information.</p>
          

          
          <div class="method-source-code" id="validate_schema-source">
            <pre>static VALUE rxml_document_validate_schema(VALUE self, VALUE schema)
{
  xmlSchemaValidCtxtPtr vptr;
  xmlDocPtr xdoc;
  xmlSchemaPtr xschema;
  int is_invalid;

  Data_Get_Struct(self, xmlDoc, xdoc);
  Data_Get_Struct(schema, xmlSchema, xschema);

  vptr = xmlSchemaNewValidCtxt(xschema);

  is_invalid = xmlSchemaValidateDoc(vptr, xdoc);
  xmlSchemaFreeValidCtxt(vptr);
  if (is_invalid)
  {
    rxml_raise(&amp;xmlLastError);
    return Qfalse;
  }
  else
  {
    return Qtrue;
  }
}</pre>
          </div><!-- validate_schema-source -->
          
        </div>

        

        
      </div><!-- validate_schema-method -->

    
      <div id="method-i-version" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            version &rarr; &quot;version&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the <a href="../XML.html">XML</a> version specified by this
document.</p>
          

          
          <div class="method-source-code" id="version-source">
            <pre>static VALUE rxml_document_version_get(VALUE self)
{
  xmlDocPtr xdoc;

  Data_Get_Struct(self, xmlDoc, xdoc);
  if (xdoc-&gt;version == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) xdoc-&gt;version, NULL));
}</pre>
          </div><!-- version-source -->
          
        </div>

        

        
      </div><!-- version-method -->

    
      <div id="method-i-xhtml-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            xhtml? &rarr; (true|false)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this is an XHTML document.</p>
          

          
          <div class="method-source-code" id="xhtml-3F-source">
            <pre>static VALUE rxml_document_xhtml_q(VALUE self)
{
  xmlDocPtr xdoc;
        xmlDtdPtr xdtd;
  Data_Get_Struct(self, xmlDoc, xdoc);
        xdtd = xmlGetIntSubset(xdoc);
  if (xdtd != NULL &amp;&amp; xmlIsXHTML(xdtd-&gt;SystemID, xdtd-&gt;ExternalID) &gt; 0)
    return (Qtrue);
  else
    return (Qfalse);
}</pre>
          </div><!-- xhtml-3F-source -->
          
        </div>

        

        
      </div><!-- xhtml-3F-method -->

    
      <div id="method-i-xinclude" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            xinclude &rarr; num
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Process xinclude directives in this document.</p>
          

          
          <div class="method-source-code" id="xinclude-source">
            <pre>static VALUE rxml_document_xinclude(VALUE self)
{
#ifdef LIBXML_XINCLUDE_ENABLED
  xmlDocPtr xdoc;

  int ret;

  Data_Get_Struct(self, xmlDoc, xdoc);
  ret = xmlXIncludeProcess(xdoc);
  if (ret &gt;= 0)
  {
    return(INT2NUM(ret));
  }
  else
  {
    rxml_raise(&amp;xmlLastError);
    return Qnil;
  }
#else
  rb_warn(
      &quot;libxml was compiled without XInclude support.  Please recompile libxml and ruby-libxml&quot;);
  return (Qfalse);
#endif
}</pre>
          </div><!-- xinclude-source -->
          
        </div>

        

        
      </div><!-- xinclude-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

